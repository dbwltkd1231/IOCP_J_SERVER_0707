// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONTROLSERVERPROTOCOL_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_CONTROLSERVERPROTOCOL_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace protocol {

struct REQUEST_LOBBYINFO;
struct REQUEST_LOBBYINFOBuilder;

struct RESPONSE_LOBBYINFO;
struct RESPONSE_LOBBYINFOBuilder;

struct NOTICE_LOBBYREADY;
struct NOTICE_LOBBYREADYBuilder;

struct NOTICE_LOBBYINFO;
struct NOTICE_LOBBYINFOBuilder;

struct NOTICE_SECRETKEY;
struct NOTICE_SECRETKEYBuilder;

struct NOTICE_RESPONSESPEED;
struct NOTICE_RESPONSESPEEDBuilder;

struct CONTROL_SERVER_PROTOCOL;
struct CONTROL_SERVER_PROTOCOLBuilder;

enum MESSAGETYPE : int32_t {
  MESSAGETYPE_BEGIN = 0,
  MESSAGETYPE_REQUEST_LOBBYINFO = 1,
  MESSAGETYPE_RESPONSE_LOBBYINFO = 2,
  MESSAGETYPE_NOTICE_LOBBYREADY = 3,
  MESSAGETYPE_NOTICE_LOBBYINFO = 4,
  MESSAGETYPE_NOTICE_SECRETKEY = 5,
  MESSAGETYPE_NOTICE_RESPONSESPEED = 6,
  MESSAGETYPE_END = 7,
  MESSAGETYPE_MIN = MESSAGETYPE_BEGIN,
  MESSAGETYPE_MAX = MESSAGETYPE_END
};

inline const MESSAGETYPE (&EnumValuesMESSAGETYPE())[8] {
  static const MESSAGETYPE values[] = {
    MESSAGETYPE_BEGIN,
    MESSAGETYPE_REQUEST_LOBBYINFO,
    MESSAGETYPE_RESPONSE_LOBBYINFO,
    MESSAGETYPE_NOTICE_LOBBYREADY,
    MESSAGETYPE_NOTICE_LOBBYINFO,
    MESSAGETYPE_NOTICE_SECRETKEY,
    MESSAGETYPE_NOTICE_RESPONSESPEED,
    MESSAGETYPE_END
  };
  return values;
}

inline const char * const *EnumNamesMESSAGETYPE() {
  static const char * const names[9] = {
    "BEGIN",
    "REQUEST_LOBBYINFO",
    "RESPONSE_LOBBYINFO",
    "NOTICE_LOBBYREADY",
    "NOTICE_LOBBYINFO",
    "NOTICE_SECRETKEY",
    "NOTICE_RESPONSESPEED",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameMESSAGETYPE(MESSAGETYPE e) {
  if (::flatbuffers::IsOutRange(e, MESSAGETYPE_BEGIN, MESSAGETYPE_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMESSAGETYPE()[index];
}

enum Content : uint8_t {
  Content_NONE = 0,
  Content_REQUEST_LOBBYINFO = 1,
  Content_RESPONSE_LOBBYINFO = 2,
  Content_NOTICE_LOBBYREADY = 3,
  Content_NOTICE_LOBBYINFO = 4,
  Content_NOTICE_SECRETKEY = 5,
  Content_NOTICE_RESPONSESPEED = 6,
  Content_MIN = Content_NONE,
  Content_MAX = Content_NOTICE_RESPONSESPEED
};

inline const Content (&EnumValuesContent())[7] {
  static const Content values[] = {
    Content_NONE,
    Content_REQUEST_LOBBYINFO,
    Content_RESPONSE_LOBBYINFO,
    Content_NOTICE_LOBBYREADY,
    Content_NOTICE_LOBBYINFO,
    Content_NOTICE_SECRETKEY,
    Content_NOTICE_RESPONSESPEED
  };
  return values;
}

inline const char * const *EnumNamesContent() {
  static const char * const names[8] = {
    "NONE",
    "REQUEST_LOBBYINFO",
    "RESPONSE_LOBBYINFO",
    "NOTICE_LOBBYREADY",
    "NOTICE_LOBBYINFO",
    "NOTICE_SECRETKEY",
    "NOTICE_RESPONSESPEED",
    nullptr
  };
  return names;
}

inline const char *EnumNameContent(Content e) {
  if (::flatbuffers::IsOutRange(e, Content_NONE, Content_NOTICE_RESPONSESPEED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesContent()[index];
}

template<typename T> struct ContentTraits {
  static const Content enum_value = Content_NONE;
};

template<> struct ContentTraits<protocol::REQUEST_LOBBYINFO> {
  static const Content enum_value = Content_REQUEST_LOBBYINFO;
};

template<> struct ContentTraits<protocol::RESPONSE_LOBBYINFO> {
  static const Content enum_value = Content_RESPONSE_LOBBYINFO;
};

template<> struct ContentTraits<protocol::NOTICE_LOBBYREADY> {
  static const Content enum_value = Content_NOTICE_LOBBYREADY;
};

template<> struct ContentTraits<protocol::NOTICE_LOBBYINFO> {
  static const Content enum_value = Content_NOTICE_LOBBYINFO;
};

template<> struct ContentTraits<protocol::NOTICE_SECRETKEY> {
  static const Content enum_value = Content_NOTICE_SECRETKEY;
};

template<> struct ContentTraits<protocol::NOTICE_RESPONSESPEED> {
  static const Content enum_value = Content_NOTICE_RESPONSESPEED;
};

bool VerifyContent(::flatbuffers::Verifier &verifier, const void *obj, Content type);
bool VerifyContentVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct REQUEST_LOBBYINFO FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef REQUEST_LOBBYINFOBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct REQUEST_LOBBYINFOBuilder {
  typedef REQUEST_LOBBYINFO Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(REQUEST_LOBBYINFO::VT_KEY, key);
  }
  explicit REQUEST_LOBBYINFOBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<REQUEST_LOBBYINFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<REQUEST_LOBBYINFO>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<REQUEST_LOBBYINFO> CreateREQUEST_LOBBYINFO(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0) {
  REQUEST_LOBBYINFOBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<REQUEST_LOBBYINFO> CreateREQUEST_LOBBYINFODirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return protocol::CreateREQUEST_LOBBYINFO(
      _fbb,
      key__);
}

struct RESPONSE_LOBBYINFO FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RESPONSE_LOBBYINFOBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEEDBACK = 4,
    VT_LOBBY_NAME = 6,
    VT_PORT = 8
  };
  bool feedback() const {
    return GetField<uint8_t>(VT_FEEDBACK, 0) != 0;
  }
  const ::flatbuffers::String *lobby_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOBBY_NAME);
  }
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FEEDBACK, 1) &&
           VerifyOffset(verifier, VT_LOBBY_NAME) &&
           verifier.VerifyString(lobby_name()) &&
           VerifyField<int32_t>(verifier, VT_PORT, 4) &&
           verifier.EndTable();
  }
};

struct RESPONSE_LOBBYINFOBuilder {
  typedef RESPONSE_LOBBYINFO Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_feedback(bool feedback) {
    fbb_.AddElement<uint8_t>(RESPONSE_LOBBYINFO::VT_FEEDBACK, static_cast<uint8_t>(feedback), 0);
  }
  void add_lobby_name(::flatbuffers::Offset<::flatbuffers::String> lobby_name) {
    fbb_.AddOffset(RESPONSE_LOBBYINFO::VT_LOBBY_NAME, lobby_name);
  }
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(RESPONSE_LOBBYINFO::VT_PORT, port, 0);
  }
  explicit RESPONSE_LOBBYINFOBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RESPONSE_LOBBYINFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RESPONSE_LOBBYINFO>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RESPONSE_LOBBYINFO> CreateRESPONSE_LOBBYINFO(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool feedback = false,
    ::flatbuffers::Offset<::flatbuffers::String> lobby_name = 0,
    int32_t port = 0) {
  RESPONSE_LOBBYINFOBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_lobby_name(lobby_name);
  builder_.add_feedback(feedback);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RESPONSE_LOBBYINFO> CreateRESPONSE_LOBBYINFODirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool feedback = false,
    const char *lobby_name = nullptr,
    int32_t port = 0) {
  auto lobby_name__ = lobby_name ? _fbb.CreateString(lobby_name) : 0;
  return protocol::CreateRESPONSE_LOBBYINFO(
      _fbb,
      feedback,
      lobby_name__,
      port);
}

struct NOTICE_LOBBYREADY FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NOTICE_LOBBYREADYBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_PORT = 6,
    VT_ACTIVE = 8
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<int32_t>(verifier, VT_PORT, 4) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE, 1) &&
           verifier.EndTable();
  }
};

struct NOTICE_LOBBYREADYBuilder {
  typedef NOTICE_LOBBYREADY Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(NOTICE_LOBBYREADY::VT_KEY, key);
  }
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(NOTICE_LOBBYREADY::VT_PORT, port, 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(NOTICE_LOBBYREADY::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  explicit NOTICE_LOBBYREADYBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NOTICE_LOBBYREADY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NOTICE_LOBBYREADY>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NOTICE_LOBBYREADY> CreateNOTICE_LOBBYREADY(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    int32_t port = 0,
    bool active = false) {
  NOTICE_LOBBYREADYBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_key(key);
  builder_.add_active(active);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NOTICE_LOBBYREADY> CreateNOTICE_LOBBYREADYDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    int32_t port = 0,
    bool active = false) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return protocol::CreateNOTICE_LOBBYREADY(
      _fbb,
      key__,
      port,
      active);
}

struct NOTICE_LOBBYINFO FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NOTICE_LOBBYINFOBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_CURRENT = 6,
    VT_REAMAIN = 8
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  int32_t current() const {
    return GetField<int32_t>(VT_CURRENT, 0);
  }
  int32_t reamain() const {
    return GetField<int32_t>(VT_REAMAIN, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<int32_t>(verifier, VT_CURRENT, 4) &&
           VerifyField<int32_t>(verifier, VT_REAMAIN, 4) &&
           verifier.EndTable();
  }
};

struct NOTICE_LOBBYINFOBuilder {
  typedef NOTICE_LOBBYINFO Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(NOTICE_LOBBYINFO::VT_KEY, key);
  }
  void add_current(int32_t current) {
    fbb_.AddElement<int32_t>(NOTICE_LOBBYINFO::VT_CURRENT, current, 0);
  }
  void add_reamain(int32_t reamain) {
    fbb_.AddElement<int32_t>(NOTICE_LOBBYINFO::VT_REAMAIN, reamain, 0);
  }
  explicit NOTICE_LOBBYINFOBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NOTICE_LOBBYINFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NOTICE_LOBBYINFO>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NOTICE_LOBBYINFO> CreateNOTICE_LOBBYINFO(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    int32_t current = 0,
    int32_t reamain = 0) {
  NOTICE_LOBBYINFOBuilder builder_(_fbb);
  builder_.add_reamain(reamain);
  builder_.add_current(current);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NOTICE_LOBBYINFO> CreateNOTICE_LOBBYINFODirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    int32_t current = 0,
    int32_t reamain = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return protocol::CreateNOTICE_LOBBYINFO(
      _fbb,
      key__,
      current,
      reamain);
}

struct NOTICE_SECRETKEY FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NOTICE_SECRETKEYBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SECRET_KEY = 4
  };
  const ::flatbuffers::String *secret_key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SECRET_KEY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SECRET_KEY) &&
           verifier.VerifyString(secret_key()) &&
           verifier.EndTable();
  }
};

struct NOTICE_SECRETKEYBuilder {
  typedef NOTICE_SECRETKEY Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_secret_key(::flatbuffers::Offset<::flatbuffers::String> secret_key) {
    fbb_.AddOffset(NOTICE_SECRETKEY::VT_SECRET_KEY, secret_key);
  }
  explicit NOTICE_SECRETKEYBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NOTICE_SECRETKEY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NOTICE_SECRETKEY>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NOTICE_SECRETKEY> CreateNOTICE_SECRETKEY(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> secret_key = 0) {
  NOTICE_SECRETKEYBuilder builder_(_fbb);
  builder_.add_secret_key(secret_key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NOTICE_SECRETKEY> CreateNOTICE_SECRETKEYDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *secret_key = nullptr) {
  auto secret_key__ = secret_key ? _fbb.CreateString(secret_key) : 0;
  return protocol::CreateNOTICE_SECRETKEY(
      _fbb,
      secret_key__);
}

struct NOTICE_RESPONSESPEED FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NOTICE_RESPONSESPEEDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_RESPONSE_TIME = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  float response_time() const {
    return GetField<float>(VT_RESPONSE_TIME, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<float>(verifier, VT_RESPONSE_TIME, 4) &&
           verifier.EndTable();
  }
};

struct NOTICE_RESPONSESPEEDBuilder {
  typedef NOTICE_RESPONSESPEED Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(NOTICE_RESPONSESPEED::VT_KEY, key);
  }
  void add_response_time(float response_time) {
    fbb_.AddElement<float>(NOTICE_RESPONSESPEED::VT_RESPONSE_TIME, response_time, 0.0f);
  }
  explicit NOTICE_RESPONSESPEEDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NOTICE_RESPONSESPEED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NOTICE_RESPONSESPEED>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NOTICE_RESPONSESPEED> CreateNOTICE_RESPONSESPEED(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    float response_time = 0.0f) {
  NOTICE_RESPONSESPEEDBuilder builder_(_fbb);
  builder_.add_response_time(response_time);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NOTICE_RESPONSESPEED> CreateNOTICE_RESPONSESPEEDDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    float response_time = 0.0f) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return protocol::CreateNOTICE_RESPONSESPEED(
      _fbb,
      key__,
      response_time);
}

struct CONTROL_SERVER_PROTOCOL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CONTROL_SERVER_PROTOCOLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_CONTENT_TYPE = 6,
    VT_CONTENT = 8
  };
  protocol::MESSAGETYPE message_type() const {
    return static_cast<protocol::MESSAGETYPE>(GetField<int32_t>(VT_MESSAGE_TYPE, 0));
  }
  protocol::Content content_type() const {
    return static_cast<protocol::Content>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const protocol::REQUEST_LOBBYINFO *content_as_REQUEST_LOBBYINFO() const {
    return content_type() == protocol::Content_REQUEST_LOBBYINFO ? static_cast<const protocol::REQUEST_LOBBYINFO *>(content()) : nullptr;
  }
  const protocol::RESPONSE_LOBBYINFO *content_as_RESPONSE_LOBBYINFO() const {
    return content_type() == protocol::Content_RESPONSE_LOBBYINFO ? static_cast<const protocol::RESPONSE_LOBBYINFO *>(content()) : nullptr;
  }
  const protocol::NOTICE_LOBBYREADY *content_as_NOTICE_LOBBYREADY() const {
    return content_type() == protocol::Content_NOTICE_LOBBYREADY ? static_cast<const protocol::NOTICE_LOBBYREADY *>(content()) : nullptr;
  }
  const protocol::NOTICE_LOBBYINFO *content_as_NOTICE_LOBBYINFO() const {
    return content_type() == protocol::Content_NOTICE_LOBBYINFO ? static_cast<const protocol::NOTICE_LOBBYINFO *>(content()) : nullptr;
  }
  const protocol::NOTICE_SECRETKEY *content_as_NOTICE_SECRETKEY() const {
    return content_type() == protocol::Content_NOTICE_SECRETKEY ? static_cast<const protocol::NOTICE_SECRETKEY *>(content()) : nullptr;
  }
  const protocol::NOTICE_RESPONSESPEED *content_as_NOTICE_RESPONSESPEED() const {
    return content_type() == protocol::Content_NOTICE_RESPONSESPEED ? static_cast<const protocol::NOTICE_RESPONSESPEED *>(content()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MESSAGE_TYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyContent(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const protocol::REQUEST_LOBBYINFO *CONTROL_SERVER_PROTOCOL::content_as<protocol::REQUEST_LOBBYINFO>() const {
  return content_as_REQUEST_LOBBYINFO();
}

template<> inline const protocol::RESPONSE_LOBBYINFO *CONTROL_SERVER_PROTOCOL::content_as<protocol::RESPONSE_LOBBYINFO>() const {
  return content_as_RESPONSE_LOBBYINFO();
}

template<> inline const protocol::NOTICE_LOBBYREADY *CONTROL_SERVER_PROTOCOL::content_as<protocol::NOTICE_LOBBYREADY>() const {
  return content_as_NOTICE_LOBBYREADY();
}

template<> inline const protocol::NOTICE_LOBBYINFO *CONTROL_SERVER_PROTOCOL::content_as<protocol::NOTICE_LOBBYINFO>() const {
  return content_as_NOTICE_LOBBYINFO();
}

template<> inline const protocol::NOTICE_SECRETKEY *CONTROL_SERVER_PROTOCOL::content_as<protocol::NOTICE_SECRETKEY>() const {
  return content_as_NOTICE_SECRETKEY();
}

template<> inline const protocol::NOTICE_RESPONSESPEED *CONTROL_SERVER_PROTOCOL::content_as<protocol::NOTICE_RESPONSESPEED>() const {
  return content_as_NOTICE_RESPONSESPEED();
}

struct CONTROL_SERVER_PROTOCOLBuilder {
  typedef CONTROL_SERVER_PROTOCOL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type(protocol::MESSAGETYPE message_type) {
    fbb_.AddElement<int32_t>(CONTROL_SERVER_PROTOCOL::VT_MESSAGE_TYPE, static_cast<int32_t>(message_type), 0);
  }
  void add_content_type(protocol::Content content_type) {
    fbb_.AddElement<uint8_t>(CONTROL_SERVER_PROTOCOL::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(::flatbuffers::Offset<void> content) {
    fbb_.AddOffset(CONTROL_SERVER_PROTOCOL::VT_CONTENT, content);
  }
  explicit CONTROL_SERVER_PROTOCOLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CONTROL_SERVER_PROTOCOL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CONTROL_SERVER_PROTOCOL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CONTROL_SERVER_PROTOCOL> CreateCONTROL_SERVER_PROTOCOL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    protocol::MESSAGETYPE message_type = protocol::MESSAGETYPE_BEGIN,
    protocol::Content content_type = protocol::Content_NONE,
    ::flatbuffers::Offset<void> content = 0) {
  CONTROL_SERVER_PROTOCOLBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_message_type(message_type);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline bool VerifyContent(::flatbuffers::Verifier &verifier, const void *obj, Content type) {
  switch (type) {
    case Content_NONE: {
      return true;
    }
    case Content_REQUEST_LOBBYINFO: {
      auto ptr = reinterpret_cast<const protocol::REQUEST_LOBBYINFO *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Content_RESPONSE_LOBBYINFO: {
      auto ptr = reinterpret_cast<const protocol::RESPONSE_LOBBYINFO *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Content_NOTICE_LOBBYREADY: {
      auto ptr = reinterpret_cast<const protocol::NOTICE_LOBBYREADY *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Content_NOTICE_LOBBYINFO: {
      auto ptr = reinterpret_cast<const protocol::NOTICE_LOBBYINFO *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Content_NOTICE_SECRETKEY: {
      auto ptr = reinterpret_cast<const protocol::NOTICE_SECRETKEY *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Content_NOTICE_RESPONSESPEED: {
      auto ptr = reinterpret_cast<const protocol::NOTICE_RESPONSESPEED *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyContentVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyContent(
        verifier,  values->Get(i), types->GetEnum<Content>(i))) {
      return false;
    }
  }
  return true;
}

inline const protocol::CONTROL_SERVER_PROTOCOL *GetCONTROL_SERVER_PROTOCOL(const void *buf) {
  return ::flatbuffers::GetRoot<protocol::CONTROL_SERVER_PROTOCOL>(buf);
}

inline const protocol::CONTROL_SERVER_PROTOCOL *GetSizePrefixedCONTROL_SERVER_PROTOCOL(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<protocol::CONTROL_SERVER_PROTOCOL>(buf);
}

inline bool VerifyCONTROL_SERVER_PROTOCOLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<protocol::CONTROL_SERVER_PROTOCOL>(nullptr);
}

inline bool VerifySizePrefixedCONTROL_SERVER_PROTOCOLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<protocol::CONTROL_SERVER_PROTOCOL>(nullptr);
}

inline void FinishCONTROL_SERVER_PROTOCOLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<protocol::CONTROL_SERVER_PROTOCOL> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCONTROL_SERVER_PROTOCOLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<protocol::CONTROL_SERVER_PROTOCOL> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace protocol

#endif  // FLATBUFFERS_GENERATED_CONTROLSERVERPROTOCOL_PROTOCOL_H_
